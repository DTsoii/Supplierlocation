import pandas as pd
import googlemaps
import time

# Replace with your actual API key
gmaps = googlemaps.Client(key='AIzaSyAflcddk_x1pC8rPooMAaAwkpvuZ8rvJ3c')

# Read data from CSV file
df = pd.read_csv('/Users/daphne/Desktop/Programmatic_Search.csv')

# Ensure that the DataFrame has the necessary columns
required_columns = {'Supplier name', 'Country'}
if not required_columns.issubset(df.columns):
    raise ValueError(f"The CSV file must contain the columns: {required_columns}")

def get_place_details(supplier_name, country):
    query = f"{supplier_name}, {country}"
    retries = 3
    for attempt in range(retries):
        try:
            print(f"Querying for: {supplier_name} in {country} (Attempt {attempt + 1})")
            places_result = gmaps.places(query)
            if places_result['status'] == 'OK' and places_result['results']:
                place_id = places_result['results'][0]['place_id']
                place_details = gmaps.place(place_id=place_id, language='en')
                if place_details['status'] == 'OK':
                    result = place_details['result']
                    business_name = result.get('name')  # Get business name
                    formatted_address = result.get('formatted_address')
                    address_components = result.get('address_components', [])
                    city = None
                    state = None
                    for component in address_components:
                        if 'locality' in component['types']:
                            city = component['long_name']
                        elif 'administrative_area_level_1' in component['types']:
                            state = component['long_name']
                    return pd.Series([business_name, formatted_address, city, state])
                else:
                    print(f"Place details not found for {supplier_name}")
                    return pd.Series([None, None, None, None])
            else:
                print(f"No results found for {supplier_name} in {country}")
                return pd.Series([None, None, None, None])
        except Exception as e:
            print(f"Error retrieving data for {supplier_name} (Attempt {attempt + 1}): {e}")
        
        time.sleep(2)
    
    return pd.Series([None, None, None, None])

# Apply the function to your DataFrame with progress monitoring
df[['Google Business Name', 'Address', 'City', 'State']] = df.apply(
    lambda row: get_place_details(row['Supplier name'], row['Country']),
    axis=1
)

# Add a delay between each row processing
time.sleep(1)

# Enriched country-language mapping
def assign_language(row):
    country_language_map = {
        'AFGHANISTAN': 'Pashto, Dari', 'ALBANIA': 'Albanian', 'ALGERIA': 'Arabic', 'ANGOLA': 'Portuguese',
        'ARGENTINA': 'Spanish', 'ARMENIA': 'Armenian', 'AUSTRALIA': 'English', 'AUSTRIA': 'German',
        'AZERBAIJAN': 'Azerbaijani', 'BAHRAIN': 'Arabic', 'BANGLADESH': 'Bengali', 'BARBADOS': 'English',
        'BELARUS': 'Belarusian, Russian', 'BELGIUM': 'Dutch, French, German', 'BRAZIL': 'Portuguese',
        'BULGARIA': 'Bulgarian', 'CAMBODIA': 'Khmer', 'CANADA': 'English, French', 'CHILE': 'Spanish',
        'CHINA': 'Simplified Chinese', 'COLOMBIA': 'Spanish', 'COSTA RICA': 'Spanish', 'CROATIA': 'Croatian',
        'CZECH REPUBLIC': 'Czech', 'DENMARK': 'Danish', 'EGYPT': 'Arabic', 'ESTONIA': 'Estonian',
        'ETHIOPIA': 'Amharic', 'FINLAND': 'Finnish, Swedish', 'FRANCE': 'French', 'GERMANY': 'German',
        'GHANA': 'English', 'GREECE': 'Greek', 'HUNGARY': 'Hungarian', 'ICELAND': 'Icelandic',
        'INDIA': 'Hindi, English', 'INDONESIA': 'Indonesian', 'IRAN': 'Persian', 'IRAQ': 'Arabic, Kurdish',
        'IRELAND': 'English, Irish', 'ISRAEL': 'Hebrew, Arabic', 'ITALY': 'Italian', 'JAPAN': 'Japanese',
        'JORDAN': 'Arabic', 'KENYA': 'Swahili, English', 'KUWAIT': 'Arabic', 'LATVIA': 'Latvian',
        'LEBANON': 'Arabic', 'LIBYA': 'Arabic', 'LITHUANIA': 'Lithuanian', 'LUXEMBOURG': 'Luxembourgish, French, German',
        'MALAYSIA': 'Malay', 'MEXICO': 'Spanish', 'MOROCCO': 'Arabic', 'MYANMAR': 'Burmese',
        'NEPAL': 'Nepali', 'NETHERLANDS': 'Dutch', 'NEW ZEALAND': 'English, MƒÅori', 'NIGERIA': 'English',
        'NORWAY': 'Norwegian', 'OMAN': 'Arabic', 'PAKISTAN': 'Urdu, English', 'PERU': 'Spanish',
        'PHILIPPINES': 'Filipino, English', 'POLAND': 'Polish', 'PORTUGAL': 'Portuguese', 'QATAR': 'Arabic',
        'ROMANIA': 'Romanian', 'RUSSIA': 'Russian', 'SAUDI ARABIA': 'Arabic', 'SINGAPORE': 'English',
        'SLOVAKIA': 'Slovak', 'SOUTH AFRICA': 'English, Afrikaans, Zulu', 'SOUTH KOREA': 'Korean', 
        'SPAIN': 'Spanish', 'SRI LANKA': 'Sinhala, Tamil', 'SWEDEN': 'Swedish', 'SWITZERLAND': 'German, French, Italian, Romansh',
        'SYRIA': 'Arabic', 'TAIWAN': 'Traditional Chinese', 'THAILAND': 'Thai', 'TURKEY': 'Turkish',
        'UKRAINE': 'Ukrainian', 'UNITED ARAB EMIRATES': 'Arabic', 'UNITED KINGDOM': 'English',
        'UNITED STATES': 'English', 'HONG KONG': 'Traditional Chinese', 'VIETNAM': 'Vietnamese',
    }

    # Mapping of Indian states to languages
    india_state_language_map = {
        'Andhra Pradesh': 'Telugu', 'Arunachal Pradesh': 'English', 'Assam': 'Assamese', 'Bihar': 'Hindi',
        'Chhattisgarh': 'Hindi', 'Goa': 'Konkani', 'Gujarat': 'Gujarati', 'Haryana': 'Hindi', 'Himachal Pradesh': 'Hindi',
        'Jharkhand': 'Hindi', 'Karnataka': 'Kannada', 'Kerala': 'Malayalam', 'Madhya Pradesh': 'Hindi',
        'Maharashtra': 'Marathi', 'Manipur': 'Manipuri', 'Meghalaya': 'English', 'Mizoram': 'Mizo',
        'Nagaland': 'English', 'Odisha': 'Odia', 'Punjab': 'Punjabi', 'Rajasthan': 'Hindi', 'Sikkim': 'English',
        'Tamil Nadu': 'Tamil', 'Telangana': 'Telugu', 'Tripura': 'Bengali', 'Uttar Pradesh': 'Hindi', 'Uttarakhand': 'Hindi',
        'West Bengal': 'Bengali', 'Delhi': 'Hindi', 'Puducherry': 'Tamil', 'Chandigarh': 'Punjabi, Hindi', 'Jammu and Kashmir': 'Urdu',
        'Ladakh': 'Ladakhi',
    }

    country = row['Country'].upper()
    if country == 'INDIA':
        state = row['State']
        return india_state_language_map.get(state, 'Hindi')
    else:
        return country_language_map.get(country, 'English')

df['Language'] = df.apply(assign_language, axis=1)

# Mapping languages to scripts
def classify_script(language):
    roman_languages = [
        'English', 'French', 'German', 'Spanish', 'Portuguese', 'Italian', 'Dutch',
        'Swedish', 'Norwegian', 'Danish', 'Finnish', 'Icelandic', 'Romanian',
        'Albanian', 'Maltese', 'Turkish', 'Vietnamese', 'Filipino', 'Afrikaans',
        'Irish', 'Estonian', 'Latvian', 'Lithuanian', 'Swahili', 'Malay', 'Indonesian',
        'Hungarian', 'Czech', 'Slovak', 'Polish', 'Croatian', 'Slovene', 'Slovenian',
        'Spanish', 'Catalan', 'Galician', 'Basque', 'Zulu', 'Xhosa', 'Konkani', 'Hindi',
        'Bengali', 'Gujarati', 'Marathi', 'Punjabi', 'Tamil', 'Telugu', 'Kannada',
        'Malayalam', 'Odia', 'Assamese', 'Urdu', 'Sindhi', 'Kashmiri',
    ]
    primary_language = language.split(',')[0].strip()
    return 'Roman' if primary_language in roman_languages else 'Non-Roman'

df['Roman/ non-roman'] = df['Language'].apply(classify_script)

# Keep only the specified columns
df = df[['Supplier name', 'Google Business Name', 'Country', 'Address', 'City', 'State', 'Roman/ non-roman', 'Language']]

# Output to CSV
output_path = '/Users/daphne/Desktop/programmatic_search_ready.csv'
df.to_csv(output_path, index=False)
print(f"CSV saved to {output_path}")

# Print the DataFrame for verification
print(df)
